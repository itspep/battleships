<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Battleship ğŸš¢âš“</title>

</head>
<body>
    <div class="game-container">
        <!-- Game Header -->
        <header class="game-header">
            <h1>Battleship</h1>
            <div class="game-info">
                <div class="turn-indicator" id="turnIndicator">Your Turn</div>
                <div class="game-status" id="gameStatus">Place your ships to start</div>
            </div>
        </header>

        <!-- Main Game Area -->
        <main class="game-main">
            <!-- Player Board -->
            <section class="board-section">
                <h2>Your Fleet</h2>
                <div class="board-container">
                    <div class="board" id="playerBoard"></div>
                    <div class="ship-status" id="playerShipStatus"></div>
                </div>
            </section>

            <!-- Computer Board -->
            <section class="board-section">
                <h2>Enemy Waters</h2>
                <div class="board-container">
                    <div class="board" id="computerBoard"></div>
                    <div class="ship-status" id="computerShipStatus"></div>
                </div>
            </section>
        </main>

        <!-- Controls -->
        <footer class="game-controls">
            <div class="ship-placement" id="shipPlacement">
                <h3>Place Your Ships</h3>
                <div class="ship-list" id="shipList"></div>
                <div class="placement-controls">
                    <button id="rotateBtn">Rotate Ship (R)</button>
                    <button id="randomBtn">Randomize All</button>
                </div>
            </div>
            
            <div class="game-buttons">
                <button id="startBtn" disabled>Start Game</button>
                <button id="resetBtn">Reset Game</button>
            </div>
        </footer>
    </div>

    <!-- Game Over Modal -->
    <div class="modal" id="gameOverModal">
        <div class="modal-content">
            <h2 id="modalTitle">Game Over</h2>
            <p id="modalMessage"></p>
            <button id="playAgainBtn">Play Again</button>
        </div>
    </div>

</body>
</html>














* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }
  
  :root {
    --primary-blue: #1a365d;
    --secondary-blue: #2d3748;
    --accent-blue: #3182ce;
    --ocean-dark: #2c5282;
    --ocean-light: #4299e1;
    --hit-red: #e53e3e;
    --miss-gray: #a0aec0;
    --ship-color: #4a5568;
    --text-light: #f7fafc;
    --text-dark: #2d3748;
    --shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    --shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.1);
  }
  
  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    min-height: 100vh;
    color: var(--text-light);
  }
  
  /* Game Container */
  .game-container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
  }
  
  /* Header */
  .game-header {
    text-align: center;
    margin-bottom: 30px;
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    padding: 20px;
    border-radius: 15px;
    border: 1px solid rgba(255, 255, 255, 0.2);
  }
  
  .game-header h1 {
    font-size: 2.5rem;
    margin-bottom: 10px;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
  }
  
  .game-info {
    display: flex;
    justify-content: center;
    gap: 30px;
    flex-wrap: wrap;
  }
  
  .turn-indicator {
    background: var(--accent-blue);
    padding: 8px 16px;
    border-radius: 20px;
    font-weight: bold;
    box-shadow: var(--shadow);
  }
  
  .game-status {
    background: rgba(255, 255, 255, 0.2);
    padding: 8px 16px;
    border-radius: 20px;
    font-weight: 500;
  }
  
  /* Main Game Area */
  .game-main {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 30px;
    margin-bottom: 30px;
    flex: 1;
  }
  
  @media (max-width: 768px) {
    .game-main {
        grid-template-columns: 1fr;
    }
  }
  
  .board-section {
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    padding: 20px;
    border-radius: 15px;
    border: 1px solid rgba(255, 255, 255, 0.2);
  }
  
  .board-section h2 {
    text-align: center;
    margin-bottom: 15px;
    font-size: 1.3rem;
    color: var(--text-light);
  }
  
  .board-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 15px;
  }
  
  /* Game Boards */
  .board {
    display: grid;
    grid-template-columns: repeat(10, 1fr);
    grid-template-rows: repeat(10, 1fr);
    gap: 2px;
    background: var(--ocean-dark);
    padding: 10px;
    border-radius: 8px;
    box-shadow: var(--shadow-lg);
    border: 3px solid var(--ocean-light);
  }
  
  .cell {
    width: 30px;
    height: 30px;
    background: var(--ocean-light);
    border: 1px solid var(--ocean-dark);
    border-radius: 3px;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
  }
  
  @media (max-width: 768px) {
    .cell {
        width: 25px;
        height: 25px;
    }
  }
  
  .cell:hover {
    transform: scale(1.1);
    background: #63b3ed;
  }
  
  /* Reset and Base Styles */
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }
  
  :root {
    --primary-blue: #1a365d;
    --secondary-blue: #2d3748;
    --accent-blue: #3182ce;
    --ocean-dark: #2c5282;
    --ocean-light: #4299e1;
    --hit-red: #e53e3e;
    --miss-gray: #a0aec0;
    --ship-color: #4a5568;
    --text-light: #f7fafc;
    --text-dark: #2d3748;
    --shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    --shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.1);
  }
  
  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    min-height: 100vh;
    color: var(--text-light);
  }
  
  /* Game Container */
  .game-container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
  }
  
  /* Header */
  .game-header {
    text-align: center;
    margin-bottom: 30px;
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    padding: 20px;
    border-radius: 15px;
    border: 1px solid rgba(255, 255, 255, 0.2);
  }
  
  .game-header h1 {
    font-size: 2.5rem;
    margin-bottom: 10px;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
  }
  
  .game-header h1::before {
    content: 'âš“ ';
  }
  
  .game-header h1::after {
    content: ' ğŸš¢';
  }
  
  .game-info {
    display: flex;
    justify-content: center;
    gap: 30px;
    flex-wrap: wrap;
  }
  
  .turn-indicator {
    background: var(--accent-blue);
    padding: 8px 16px;
    border-radius: 20px;
    font-weight: bold;
    box-shadow: var(--shadow);
  }
  
  .turn-indicator.human::before {
    content: 'ğŸ¯ ';
  }
  
  .turn-indicator.computer::before {
    content: 'ğŸ¤– ';
  }
  
  .game-status {
    background: rgba(255, 255, 255, 0.2);
    padding: 8px 16px;
    border-radius: 20px;
    font-weight: 500;
  }
  
  .game-status.placement::before {
    content: 'ğŸ“ ';
  }
  
  .game-status.battle::before {
    content: 'ğŸ¯ ';
  }
  
  .game-status.victory::before {
    content: 'ğŸ‰ ';
  }
  
  .game-status.defeat::before {
    content: 'ğŸ’¥ ';
  }
  
  /* Main Game Area */
  .game-main {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 30px;
    margin-bottom: 30px;
    flex: 1;
  }
  
  @media (max-width: 768px) {
    .game-main {
        grid-template-columns: 1fr;
    }
  }
  
  .board-section {
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    padding: 20px;
    border-radius: 15px;
    border: 1px solid rgba(255, 255, 255, 0.2);
  }
  
  .board-section h2 {
    text-align: center;
    margin-bottom: 15px;
    font-size: 1.3rem;
    color: var(--text-light);
  }
  
  .board-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 15px;
  }
  
  /* Game Boards */
  .board {
    display: grid;
    grid-template-columns: repeat(10, 1fr);
    grid-template-rows: repeat(10, 1fr);
    gap: 2px;
    background: var(--ocean-dark);
    padding: 10px;
    border-radius: 8px;
    box-shadow: var(--shadow-lg);
    border: 3px solid var(--ocean-light);
  }
  
  .cell {
    width: 30px;
    height: 30px;
    background: var(--ocean-light);
    border: 1px solid var(--ocean-dark);
    border-radius: 3px;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    position: relative;
  }
  
  @media (max-width: 768px) {
    .cell {
        width: 25px;
        height: 25px;
    }
  }
  
  .cell:hover {
    transform: scale(1.1);
    background: #63b3ed;
  }
  
  /* Enhanced Cell Styles with Emojis */
  .cell.ship {
    background: var(--ship-color);
    border-color: #2d3748;
  }
  
  .cell.ship::before {
    content: 'ğŸš¢';
    font-size: 12px;
    position: absolute;
  }
  
  .cell.hit {
    background: var(--hit-red);
    border-color: #c53030;
  }
  
  .cell.hit::after {
    content: 'ğŸ’¥';
    font-size: 14px;
    animation: explode 0.3s ease-out;
  }
  
  .cell.miss {
    background: var(--miss-gray);
    border-color: #718096;
  }
  
  .cell.miss::after {
    content: 'ğŸŒŠ';
    font-size: 12px;
    opacity: 0.8;
  }
  
  .cell.ship.hit {
    background: linear-gradient(45deg, var(--hit-red), #ff6b6b);
  }
  
  .cell.ship.hit::after {
    content: 'ğŸ’¥ğŸ”¥';
    font-size: 12px;
  }
  
  .cell.ship.sunk {
    background: linear-gradient(45deg, #7f1d1d, #dc2626);
    animation: sink 2s ease-in-out;
  }
  
  .cell.ship.sunk::after {
    content: 'âš°ï¸';
    font-size: 14px;
  }
  
  .cell.invalid {
    background: #fed7d7;
    border-color: #feb2b2;
  }
  
  #computerBoard .cell:not(.hit):not(.miss):hover {
    background: #90cdf4;
  }
  
  /* Ship Status with Emojis */
  .ship-status {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
    justify-content: center;
  }
  
  .ship-status-item {
    display: flex;
    align-items: center;
    gap: 8px;
    background: rgba(255, 255, 255, 0.2);
    padding: 8px 12px;
    border-radius: 20px;
    font-size: 0.9rem;
  }
  
  .ship-indicator {
    width: 20px;
    height: 10px;
    background: var(--ship-color);
    border-radius: 2px;
    position: relative;
  }
  
  .ship-indicator::before {
    content: 'ğŸš¢';
    font-size: 8px;
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
  }
  
  .ship-indicator.sunk {
    background: var(--hit-red);
  }
  
  .ship-indicator.sunk::before {
    content: 'ğŸ’€';
  }
  
  /* Controls */
  .game-controls {
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    padding: 20px;
    border-radius: 15px;
    border: 1px solid rgba(255, 255, 255, 0.2);
  }
  
  .ship-placement {
    margin-bottom: 20px;
  }
  
  .ship-placement h3 {
    text-align: center;
    margin-bottom: 15px;
  }
  
  .ship-list {
    display: flex;
    gap: 10px;
    justify-content: center;
    flex-wrap: wrap;
    margin-bottom: 15px;
  }
  
  .ship-item {
    display: flex;
    align-items: center;
    gap: 5px;
    background: rgba(255, 255, 255, 0.2);
    padding: 8px 12px;
    border-radius: 20px;
    cursor: pointer;
    transition: all 0.2s ease;
  }
  
  .ship-item::before {
    content: 'ğŸš¢ ';
    font-size: 14px;
  }
  
  .ship-item:hover {
    background: rgba(255, 255, 255, 0.3);
  }
  
  .ship-item.placing {
    background: var(--accent-blue);
  }
  
  .ship-item.placing::before {
    content: 'ğŸ¯ ';
  }
  
  .ship-preview {
    display: flex;
    gap: 2px;
  }
  
  .ship-segment {
    width: 12px;
    height: 12px;
    background: var(--ship-color);
    border-radius: 2px;
  }
  
  .placement-controls {
    display: flex;
    gap: 10px;
    justify-content: center;
    flex-wrap: wrap;
  }
  
  /* Buttons */
  button {
    background: var(--accent-blue);
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 8px;
    cursor: pointer;
    font-size: 1rem;
    font-weight: 600;
    transition: all 0.2s ease;
    box-shadow: var(--shadow);
  }
  
  button:hover {
    background: #2c5aa0;
    transform: translateY(-2px);
    box-shadow: var(--shadow-lg);
  }
  
  button:active {
    transform: translateY(0);
  }
  
  button:disabled {
    background: var(--miss-gray);
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
  }
  
  .game-buttons {
    display: flex;
    gap: 15px;
    justify-content: center;
    flex-wrap: wrap;
  }
  
  #startBtn {
    background: #38a169;
  }
  
  #startBtn:hover:not(:disabled) {
    background: #2f855a;
  }
  
  #resetBtn {
    background: var(--hit-red);
  }
  
  #resetBtn:hover {
    background: #c53030;
  }
  
  /* Modal */
  .modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    backdrop-filter: blur(5px);
    z-index: 1000;
    align-items: center;
    justify-content: center;
  }
  
  .modal.show {
    display: flex;
  }
  
  .modal-content {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    padding: 40px;
    border-radius: 20px;
    text-align: center;
    box-shadow: var(--shadow-lg);
    border: 2px solid rgba(255, 255, 255, 0.3);
    max-width: 400px;
    width: 90%;
  }
  
  .modal-content h2 {
    font-size: 2rem;
    margin-bottom: 15px;
  }
  
  .modal-content h2::before {
    content: 'ğŸ® ';
  }
  
  #modalTitle.victory::before {
    content: 'ğŸ‰ ';
  }
  
  #modalTitle.defeat::before {
    content: 'ğŸ’¥ ';
  }
  
  #modalTitle.tie::before {
    content: 'ğŸ¤ ';
  }
  
  .modal-content p {
    font-size: 1.2rem;
    margin-bottom: 25px;
  }
  
  /* Attack Feedback */
  .attack-feedback {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 20px 30px;
    border-radius: 10px;
    font-size: 1.5rem;
    z-index: 1000;
    animation: fadeInOut 2s ease-in-out;
  }
  
  /* Enhanced Animations */
  @keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
  }
  
  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(20px); }
    to { opacity: 1; transform: translateY(0); }
  }
  
  @keyframes explode {
    0% { transform: scale(0.5); opacity: 0; }
    50% { transform: scale(1.2); }
    100% { transform: scale(1); opacity: 1; }
  }
  
  @keyframes sink {
    0% { transform: translateY(0px); }
    50% { transform: translateY(3px); }
    100% { transform: translateY(0px); }
  }
  
  @keyframes float {
    0% { transform: translateY(0px); }
    50% { transform: translateY(-2px); }
    100% { transform: translateY(0px); }
  }
  
  @keyframes fadeInOut {
    0% { opacity: 0; transform: translate(-50%, -40%); }
    20% { opacity: 1; transform: translate(-50%, -50%); }
    80% { opacity: 1; transform: translate(-50%, -50%); }
    100% { opacity: 0; transform: translate(-50%, -60%); }
  }
  
  @keyframes victoryPulse {
    0% { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
    50% { background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%); }
    100% { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
  }
  
  .pulse {
    animation: pulse 2s infinite;
  }
  
  .fade-in {
    animation: fadeIn 0.5s ease-out;
  }
  
  /* Victory celebration */
  .victory-celebration {
    animation: victoryPulse 2s infinite;
  }





  export default class DOM {
    constructor(game) {
        this.game = game;
        this.initializeElements();
        this.setupEventListeners();
        this.currentShip = null;
        this.currentDirection = 'horizontal';
        this.placedShips = new Set();
        
        // Initial render
        this.createShipList();
        this.renderBoards();
    }

    initializeElements() {
        console.log('ğŸ® Initializing DOM elements...');
        
        // Boards
        this.playerBoard = document.getElementById('playerBoard');
        this.computerBoard = document.getElementById('computerBoard');
        
        // UI Elements
        this.turnIndicator = document.getElementById('turnIndicator');
        this.gameStatus = document.getElementById('gameStatus');
        this.shipList = document.getElementById('shipList');
        this.playerShipStatus = document.getElementById('playerShipStatus');
        this.computerShipStatus = document.getElementById('computerShipStatus');
        
        // Buttons
        this.rotateBtn = document.getElementById('rotateBtn');
        this.randomBtn = document.getElementById('randomBtn');
        this.startBtn = document.getElementById('startBtn');
        this.resetBtn = document.getElementById('resetBtn');
        
        // Modal
        this.modal = document.getElementById('gameOverModal');
        this.modalTitle = document.getElementById('modalTitle');
        this.modalMessage = document.getElementById('modalMessage');
        this.playAgainBtn = document.getElementById('playAgainBtn');

        console.log('âœ… Elements initialized:', {
            playerBoard: !!this.playerBoard,
            computerBoard: !!this.computerBoard,
            turnIndicator: !!this.turnIndicator
        });
    }

    setupEventListeners() {
        console.log('ğŸ¯ Setting up event listeners...');
        
        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (e.key === 'r' || e.key === 'R') {
                this.rotateShip();
            }
        });

        // Button events
        this.rotateBtn.addEventListener('click', () => this.rotateShip());
        this.randomBtn.addEventListener('click', () => this.randomizeShips());
        this.startBtn.addEventListener('click', () => this.startGame());
        this.resetBtn.addEventListener('click', () => this.resetGame());
        this.playAgainBtn.addEventListener('click', () => this.resetGame());

        console.log('âœ… Event listeners setup complete');
    }

    createShipList() {
        const ships = [
            { name: 'Carrier', length: 5 },
            { name: 'Battleship', length: 4 },
            { name: 'Cruiser', length: 3 },
            { name: 'Submarine', length: 3 },
            { name: 'Destroyer', length: 2 }
        ];

        this.shipList.innerHTML = '';
        ships.forEach(ship => {
            const shipItem = document.createElement('div');
            shipItem.className = 'ship-item';
            shipItem.dataset.length = ship.length;
            shipItem.dataset.name = ship.name;
            
            const shipPreview = document.createElement('div');
            shipPreview.className = 'ship-preview';
            
            for (let i = 0; i < ship.length; i++) {
                const segment = document.createElement('div');
                segment.className = 'ship-segment';
                shipPreview.appendChild(segment);
            }
            
            const shipName = document.createElement('span');
            shipName.textContent = ship.name;
            
            shipItem.appendChild(shipPreview);
            shipItem.appendChild(shipName);
            
            shipItem.addEventListener('click', () => {
                console.log('ğŸš¢ Ship selected:', ship.name);
                this.selectShip(ship);
            });
            
            this.shipList.appendChild(shipItem);
        });
    }

    selectShip(ship) {
        if (this.placedShips.has(ship.name)) {
            console.log('âœ… Ship already placed:', ship.name);
            this.showAttackFeedback('Ship already placed!', 'âœ…');
            return;
        }

        // Remove previous selection
        document.querySelectorAll('.ship-item').forEach(item => {
            item.classList.remove('placing');
        });

        // Set new selection
        this.currentShip = ship;
        const shipElement = document.querySelector(`[data-name="${ship.name}"]`);
        if (shipElement) {
            shipElement.classList.add('placing');
        }

        this.gameStatus.textContent = `ğŸ“ Placing ${ship.name} - Click on your board to place`;
        this.gameStatus.className = 'game-status placement';
        console.log('ğŸ¯ Ship ready for placement:', ship.name);
    }

    rotateShip() {
        this.currentDirection = this.currentDirection === 'horizontal' ? 'vertical' : 'horizontal';
        this.gameStatus.textContent = `ğŸ”„ Ship direction: ${this.currentDirection}`;
        this.rotateBtn.textContent = `ğŸ”„ Rotate Ship (R) - ${this.currentDirection}`;
        console.log('ğŸ”„ Ship direction changed to:', this.currentDirection);
    }

    renderBoards() {
        console.log('ğŸ¨ Rendering boards...');
        this.renderPlayerBoard();
        this.renderComputerBoard();
        this.updateShipStatus();
    }

    renderPlayerBoard() {
        console.log('ğŸ¯ Rendering player board...');
        this.playerBoard.innerHTML = '';
        
        for (let x = 0; x < 10; x++) {
            for (let y = 0; y < 10; y++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.dataset.x = x;
                cell.dataset.y = y;
                
                // Check if cell has a ship
                const hasShip = this.checkIfCellHasShip(x, y, 'human');
                if (hasShip) {
                    cell.classList.add('ship');
                }
                
                // Check if cell was attacked
                const wasAttacked = this.checkIfCellWasAttacked(x, y, 'human');
                if (wasAttacked) {
                    cell.classList.add(hasShip ? 'hit' : 'miss');
                    
                    // Check if ship is sunk
                    if (hasShip) {
                        const ship = this.getShipAtCoordinate(x, y, 'human');
                        if (ship && ship.isSunk()) {
                            cell.classList.add('sunk');
                        }
                    }
                }
                
                cell.addEventListener('click', (e) => {
                    console.log('ğŸ¯ Player board clicked:', x, y);
                    this.placeShip(x, y);
                });
                
                this.playerBoard.appendChild(cell);
            }
        }
        console.log('âœ… Player board rendered with', this.playerBoard.children.length, 'cells');
    }

    renderComputerBoard() {
        console.log('ğŸ¤– Rendering computer board...');
        this.computerBoard.innerHTML = '';
        
        for (let x = 0; x < 10; x++) {
            for (let y = 0; y < 10; y++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.dataset.x = x;
                cell.dataset.y = y;
                
                // Only show hits and misses on computer board
                const wasAttacked = this.checkIfCellWasAttacked(x, y, 'computer');
                if (wasAttacked) {
                    const hasShip = this.checkIfCellHasShip(x, y, 'computer');
                    cell.classList.add(hasShip ? 'hit' : 'miss');
                    
                    // Check if ship is sunk
                    if (hasShip) {
                        const ship = this.getShipAtCoordinate(x, y, 'computer');
                        if (ship && ship.isSunk()) {
                            cell.classList.add('sunk');
                        }
                    }
                }
                
                cell.addEventListener('click', (e) => {
                    console.log('ğŸ¯ Computer board clicked:', x, y, 'Game over:', this.game.gameOver, 'Current player:', this.game.currentPlayer);
                    if (!this.game.gameOver && this.game.currentPlayer === 'human') {
                        this.attackComputer(x, y);
                    } else {
                        console.log('â³ Click ignored - Game over:', this.game.gameOver, 'Current player:', this.game.currentPlayer);
                    }
                });
                
                this.computerBoard.appendChild(cell);
            }
        }
        console.log('âœ… Computer board rendered with', this.computerBoard.children.length, 'cells');
    }

    checkIfCellHasShip(x, y, player) {
        const gameboard = this.game.players[player].gameboard;
        if (!gameboard.shipPositions) return false;
        
        for (const [ship, coordinates] of gameboard.shipPositions) {
            for (const [shipX, shipY] of coordinates) {
                if (shipX === x && shipY === y) {
                    return true;
                }
            }
        }
        return false;
    }

    getShipAtCoordinate(x, y, player) {
        const gameboard = this.game.players[player].gameboard;
        if (!gameboard.shipPositions) return null;
        
        for (const [ship, coordinates] of gameboard.shipPositions) {
            for (const [shipX, shipY] of coordinates) {
                if (shipX === x && shipY === y) {
                    return ship;
                }
            }
        }
        return null;
    }

    checkIfCellWasAttacked(x, y, player) {
        const enemyType = player === 'human' ? 'computer' : 'human';
        const enemyPlayer = this.game.players[enemyType];
        return enemyPlayer.previousAttacks.has(`${x},${y}`);
    }

    placeShip(x, y) {
        console.log('ğŸ“ Attempting to place ship at:', x, y, 'Current ship:', this.currentShip);
        
        if (!this.currentShip) {
            console.log('âŒ No ship selected');
            this.showAttackFeedback('Please select a ship first!', 'âŒ');
            return;
        }

        if (this.placedShips.has(this.currentShip.name)) {
            console.log('âœ… Ship already placed:', this.currentShip.name);
            return;
        }

        try {
            this.game.players.human.gameboard.placeShip(
                this.currentShip.length,
                [x, y],
                this.currentDirection
            );
            
            this.placedShips.add(this.currentShip.name);
            console.log('âœ… Ship placed successfully:', this.currentShip.name);
            this.showAttackFeedback(`${this.currentShip.name} placed!`, 'âœ…');
            this.renderPlayerBoard();
            
            // Select next unplaced ship
            const nextShip = Array.from(document.querySelectorAll('.ship-item'))
                .find(item => !this.placedShips.has(item.dataset.name));
            
            if (nextShip) {
                this.selectShip({
                    name: nextShip.dataset.name,
                    length: parseInt(nextShip.dataset.length)
                });
            } else {
                this.currentShip = null;
                this.startBtn.disabled = false;
                this.gameStatus.textContent = 'ğŸ‰ All ships placed! Click "Start Game" to begin.';
                this.gameStatus.className = 'game-status victory';
                console.log('ğŸ‰ All ships placed');
            }
        } catch (error) {
            console.error('âŒ Placement error:', error);
            this.showAttackFeedback('Invalid placement! Try different coordinates.', 'âŒ');
        }
    }

    randomizeShips() {
        console.log('ğŸ² Randomizing ships...');
        
        // Clear existing ships
        this.game.players.human.gameboard.ships = [];
        this.game.players.human.gameboard.shipPositions = new Map();
        this.game.players.human.gameboard.allCoordinates = new Set();
        this.placedShips.clear();
        
        const ships = [
            { name: 'Carrier', length: 5 },
            { name: 'Battleship', length: 4 },
            { name: 'Cruiser', length: 3 },
            { name: 'Submarine', length: 3 },
            { name: 'Destroyer', length: 2 }
        ];

        ships.forEach(ship => {
            let placed = false;
            let attempts = 0;
            const maxAttempts = 500;
            
            while (!placed && attempts < maxAttempts) {
                const x = Math.floor(Math.random() * 10);
                const y = Math.floor(Math.random() * 10);
                const direction = Math.random() > 0.5 ? 'horizontal' : 'vertical';
                
                try {
                    this.game.players.human.gameboard.placeShip(ship.length, [x, y], direction);
                    this.placedShips.add(ship.name);
                    placed = true;
                    console.log('âœ… Random placement successful:', ship.name, 'at', x, y, direction);
                } catch (error) {
                    attempts++;
                    if (attempts === maxAttempts) {
                        console.error('âŒ Failed to place', ship.name, 'after', maxAttempts, 'attempts');
                    }
                }
            }
        });

        this.renderPlayerBoard();
        this.startBtn.disabled = this.placedShips.size === ships.length;
        
        if (this.placedShips.size === ships.length) {
            this.gameStatus.textContent = 'ğŸ‰ Ships randomly placed! Click "Start Game" to begin.';
            this.gameStatus.className = 'game-status victory';
            this.showAttackFeedback('All ships placed successfully!', 'ğŸ‰');
        } else {
            this.gameStatus.textContent = `âš ï¸ Only ${this.placedShips.size}/${ships.length} ships placed. Try again.`;
            this.showAttackFeedback('Could not place all ships. Try again.', 'âš ï¸');
        }
        
        console.log('âœ… Random placement complete:', this.placedShips.size, 'ships placed');
    }

    attackComputer(x, y) {
        console.log('ğŸ¯ Attacking computer at:', x, y);
        
        if (this.game.gameOver) {
            console.log('â³ Game is over, cannot attack');
            this.showGameOver(this.game.winner);
            return;
        }

        if (this.game.currentPlayer !== 'human') {
            console.log('â³ Not human turn, current player:', this.game.currentPlayer);
            this.showAttackFeedback('Not your turn!', 'â³');
            return;
        }

        const result = this.game.humanAttack([x, y]);
        console.log('ğŸ’¥ Attack result:', result);
        
        if (result.error) {
            this.showAttackFeedback(result.error, 'âŒ');
            return;
        }

        // Show attack feedback
        if (result.hit) {
            this.showAttackFeedback('Direct Hit!', 'ğŸ’¥');
            this.gameStatus.textContent = 'ğŸ’¥ Hit! Take another shot! ğŸ’¥';
            this.turnIndicator.textContent = 'ğŸ¯ Your Turn (Extra)';
            
            // Check if ship was sunk
            const ship = this.getShipAtCoordinate(x, y, 'computer');
            if (ship && ship.isSunk()) {
                this.showAttackFeedback('Enemy Ship Sunk!', 'âš°ï¸');
            }
        } else {
            this.showAttackFeedback('Splash! Missed...', 'ğŸŒŠ');
            this.gameStatus.textContent = 'ğŸŒŠ Miss! Computer\'s turn... ğŸŒŠ';
        }

        this.renderBoards();
        
        if (result.gameOver) {
            this.showGameOver(result.winner);
        } else if (result.turnSwitched) {
            this.updateGameStatus();
        }
    }

    updateGameStatus() {
        const currentPlayer = this.game.currentPlayer;
        
        // Update turn indicator with emojis
        if (currentPlayer === 'human') {
            this.turnIndicator.textContent = 'ğŸ¯ Your Turn';
            this.turnIndicator.className = 'turn-indicator human';
            this.gameStatus.textContent = 'ğŸ¯ Your turn - Attack enemy waters! ğŸ¯';
            this.gameStatus.className = 'game-status battle';
        } else {
            this.turnIndicator.textContent = 'ğŸ¤– Computer\'s Turn';
            this.turnIndicator.className = 'turn-indicator computer';
            this.gameStatus.textContent = 'ğŸ¤– Computer is thinking... ğŸ¤–';
            this.gameStatus.className = 'game-status battle';
        }
        
        console.log('ğŸ”„ Updating game status, current player:', currentPlayer);
        
        if (currentPlayer === 'computer' && !this.game.gameOver) {
            // Simulate computer thinking delay
            setTimeout(() => {
                console.log('ğŸ¤– Computer making attack...');
                const result = this.game.computerAttack();
                console.log('ğŸ’¥ Computer attack result:', result);
                
                this.renderBoards();
                
                // Show computer attack feedback
                if (result && result.hit) {
                    this.showAttackFeedback('Enemy hit your ship!', 'ğŸ’¢');
                    this.turnIndicator.textContent = 'ğŸ¤– Computer\'s Turn (Extra)';
                    this.gameStatus.textContent = 'ğŸ’¢ Computer hit your ship! ğŸ’¢';
                    
                    // Check if ship was sunk
                    const ship = this.getShipAtCoordinate(result.attack[0], result.attack[1], 'human');
                    if (ship && ship.isSunk()) {
                        this.showAttackFeedback('Your Ship Sunk!', 'ğŸ’€');
                    }
                } else if (result) {
                    this.showAttackFeedback('Enemy missed!', 'âœ…');
                }
                
                if (result && result.gameOver) {
                    this.showGameOver(result.winner);
                } else if (result && result.turnSwitched) {
                    this.turnIndicator.textContent = 'ğŸ¯ Your Turn';
                    this.gameStatus.textContent = 'âœ… Enemy missed! Your turn. âœ…';
                } else if (result && result.hit) {
                    // Computer hit - gets another turn
                    setTimeout(() => this.updateGameStatus(), 1000);
                }
            }, 1500);
        }
    }

    showAttackFeedback(message, emoji) {
        const feedback = document.createElement('div');
        feedback.className = 'attack-feedback';
        feedback.textContent = `${emoji} ${message} ${emoji}`;
        document.body.appendChild(feedback);
        
        setTimeout(() => {
            feedback.remove();
        }, 2000);
    }

    updateShipStatus() {
        this.updatePlayerShipStatus();
        this.updateComputerShipStatus();
    }

    updatePlayerShipStatus() {
        this.playerShipStatus.innerHTML = '<h4>ğŸ¯ Your Fleet</h4>';
        const playerShips = this.game.players.human.gameboard.ships;
        const playerSunkShips = playerShips.filter(ship => ship.isSunk()).length;
        
        const statusItem = document.createElement('div');
        statusItem.className = 'ship-status-item';
        
        if (playerSunkShips === playerShips.length) {
            statusItem.innerHTML = `ğŸ’€ All Ships Sunk! ${playerSunkShips}/${playerShips.length}`;
        } else {
            statusItem.innerHTML = `ğŸš¢ Ships: ${playerSunkShips}/${playerShips.length} sunk`;
        }
        
        this.playerShipStatus.appendChild(statusItem);
    }

    updateComputerShipStatus() {
        this.computerShipStatus.innerHTML = '<h4>ğŸ¯ Enemy Fleet</h4>';
        const computerShips = this.game.players.computer.gameboard.ships;
        const computerSunkShips = computerShips.filter(ship => ship.isSunk()).length;
        
        const statusItem = document.createElement('div');
        statusItem.className = 'ship-status-item';
        
        if (computerSunkShips === computerShips.length) {
            statusItem.innerHTML = `ğŸ‰ All Enemy Ships Sunk! ${computerSunkShips}/${computerShips.length}`;
        } else {
            statusItem.innerHTML = `ğŸš¢ Enemy: ${computerSunkShips}/${computerShips.length} sunk`;
        }
        
        this.computerShipStatus.appendChild(statusItem);
    }

    startGame() {
        console.log('ğŸš€ Starting game...');
        
        if (this.placedShips.size < 5) {
            this.gameStatus.textContent = 'âŒ Place all ships before starting!';
            this.gameStatus.className = 'game-status defeat';
            console.log('âŒ Not all ships placed:', this.placedShips.size);
            this.showAttackFeedback('Place all ships first!', 'âŒ');
            return;
        }

        // Only initialize computer ships, don't override human ships
        this.game.initializeComputerShips();
        this.gameStatus.textContent = 'ğŸ® Game started! Attack enemy waters.';
        this.gameStatus.className = 'game-status battle';
        this.startBtn.disabled = true;
        this.renderBoards();
        this.updateGameStatus();
        this.showAttackFeedback('Game Started!', 'ğŸ®');
        console.log('âœ… Game started successfully - Human ships:', this.game.players.human.gameboard.ships.length);
    }

    resetGame() {
        console.log('ğŸ”„ Resetting game...');
        
        // Create a new game instance
        this.game = new (this.game.constructor)();
        this.currentShip = null;
        this.currentDirection = 'horizontal';
        this.placedShips.clear();
        
        // Reset UI elements
        if (this.modal) this.modal.classList.remove('show');
        if (this.startBtn) this.startBtn.disabled = true;
        if (this.rotateBtn) this.rotateBtn.textContent = 'ğŸ”„ Rotate Ship (R)';
        
        this.createShipList();
        this.renderBoards();
        
        if (this.gameStatus) {
            this.gameStatus.textContent = 'ğŸ“ Place your ships to start';
            this.gameStatus.className = 'game-status placement';
        }
        if (this.turnIndicator) {
            this.turnIndicator.textContent = 'ğŸ¯ Your Turn';
            this.turnIndicator.className = 'turn-indicator human';
        }
        
        this.showAttackFeedback('Game Reset!', 'ğŸ”„');
        console.log('âœ… Game reset complete');
    }

    showGameOver(winner) {
        console.log('ğŸ® Game over, winner:', winner);
        
        // Add celebration effects
        if (winner === 'human') {
            document.body.classList.add('victory-celebration');
            this.showAttackFeedback('VICTORY! All enemy ships destroyed!', 'ğŸ‰');
        } else if (winner === 'computer') {
            this.showAttackFeedback('DEFEAT! Your fleet has been destroyed!', 'ğŸ’¥');
        } else {
            this.showAttackFeedback('TIE GAME! Mutual destruction!', 'ğŸ¤');
        }
        
        setTimeout(() => {
            if (winner === 'tie') {
                this.modalTitle.textContent = 'Game Over - Tie!';
                this.modalTitle.className = 'tie';
                this.modalMessage.textContent = 'ğŸ¤ All ships sunk! It\'s a tie game! ğŸ¤';
            } else {
                this.modalTitle.textContent = winner === 'human' ? 'Victory! ğŸ‰' : 'Defeat! ğŸ’¥';
                this.modalTitle.className = winner === 'human' ? 'victory' : 'defeat';
                this.modalMessage.textContent = winner === 'human' 
                    ? 'ğŸ‰ Congratulations! You sunk all enemy ships! ğŸ‰'
                    : 'ğŸ’¥ The computer sunk all your ships. Better luck next time! ğŸ’¥';
            }
            
            this.modal.classList.add('show');
        }, 2000);
    }
}